(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{375:function(a,t,s){"use strict";s.r(t);var r=s(42),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"cms、g1-垃圾收集器中的标记原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cms、g1-垃圾收集器中的标记原理"}},[a._v("#")]),a._v(" CMS、G1 垃圾收集器中的标记原理")]),a._v(" "),s("h3",{attrs:{id:"跨代引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨代引用"}},[a._v("#")]),a._v(" 跨代引用")]),a._v(" "),s("p",[a._v("所谓跨代引用就是老年代的对象引用了新生代的对象，或者新生代的对象引用了老年代的对象。那对于这种情况我们的GC在进行扫描的时候不可能直接把我们的整个堆都扫描完，那这样效率也太低了。所以这时候就需要开辟了一小块空间，维护这种引用，而不必让GC扫描整个堆区域。")]),a._v(" "),s("h3",{attrs:{id:"gc-root-定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gc-root-定义"}},[a._v("#")]),a._v(" GC Root 定义")]),a._v(" "),s("p",[a._v("GC root 所关联的对象是分为两个大的对象：")]),a._v(" "),s("ol",[s("li",[a._v("全局对象\n"),s("ul",[s("li",[a._v("方法区静态属性引用的对象：Class对象本身很难被回收，回收的条件非常苛刻，只要Class对象不被回收，静态成员就不能被回收。")]),a._v(" "),s("li",[a._v("方法区常量池引用的对象：例如字符串常量池，常量本身初始化后不会再改变，因此作为GC Roots也是合理的。")])])]),a._v(" "),s("li",[a._v("执行上下文\n"),s("ul",[s("li",[a._v("虚拟机栈中栈帧的局部变量表引用的对象：线程在执行方法时，会将方法打包成一个栈帧入栈执行，方法里用到的局部变量会存放到栈帧的本地变量表中。只要方法还在运行，还没出栈，就意味这本地变量表的对象还会被访问，GC就不应该回收。")]),a._v(" "),s("li",[a._v("本地方法栈中JNI (Native 方法) 引用的对象：Java方法栈中的变量引用，一个是native方法(C、C++)方法栈中的变量引用。")]),a._v(" "),s("li",[a._v("被同步锁持有的对象：被synchronized锁住的对象也是绝对不能回收。")])])])]),a._v(" "),s("h3",{attrs:{id:"gc-roots-的范围"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gc-roots-的范围"}},[a._v("#")]),a._v(" GC Roots 的范围")]),a._v(" "),s("p",[a._v("CMS 和 G1 垃圾收集器的回收过程中都存在初始标记，都是其扫描GC Root， 虚拟机为了避免全堆扫描和跨代引用的问题，引入了 Remember Set（记忆集），存储了年轻代中的对象，而 CardTable 卡表，则是 HotSpot 对于记忆集的实现，CardTable是一个字节数组(jbyte*)，数组中的每个元素称为一个card。一个内存地址可以被映射到CardTable中的一个位置上。")]),a._v(" "),s("blockquote",[s("p",[a._v("对于G1来说，每个Region都有一个CardTable，每个CardTable都有若干大小为512字节的card用于存储其它Region的对象地址。当Region A的一个对象A在引用Region B的一个对象B的时候，会通过写屏障将A对象的地址映射到Region B的CardTable中，标识对应card为dirty，之后在对Region B进行根节点枚举的时候，会把Region B的CardTable中被标记为dirty的card纳入到根节点的范围中进行扫描，以此避免去扫描Region A。\n如果对应到分代的情况，那就是在新生代中记录了老年代的一块块地址，在Minor GC的时候，直接从CardTable中获取到需要扫描的老年代对象，而不用去扫描整个老年代。")])]),a._v(" "),s("h3",{attrs:{id:"_2-三色标记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-三色标记"}},[a._v("#")]),a._v(" 2. 三色标记")]),a._v(" "),s("p",[a._v("存在于标记的过程，使用的该算法，分为三种颜色，分别对应着标记对象的状态：")]),a._v(" "),s("ul",[s("li",[a._v("黑色：从GC Roots 开始，已经扫描过它全部引用的对象，标记为黑色。（不能被回收）")]),a._v(" "),s("li",[a._v("灰色：扫描过对象本身，还没完全扫描过它全部引用的对象，标记为灰色。")]),a._v(" "),s("li",[a._v("白色：还没扫描过的对象，标记为白色。")])]),a._v(" "),s("p",[a._v("标记流程如下：")]),a._v(" "),s("ol",[s("li",[a._v("刚开始，所有的对象都是白色，没有被访问。")]),a._v(" "),s("li",[a._v("将GC Roots直接关联的对象置为灰色。")]),a._v(" "),s("li",[a._v("遍历灰色对象的所有引用，遍历后灰色对象本身置为黑色，引用置为灰色。")]),a._v(" "),s("li",[a._v("重复步骤3，直到没有灰色对象为止。结束时，黑色对象存活，白色对象回收。")])]),a._v(" "),s("h3",{attrs:{id:"_3-为什么gc-要-stw"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么gc-要-stw"}},[a._v("#")]),a._v(" 3. 为什么GC 要 STW?")]),a._v(" "),s("p",[a._v("首先，如果不暂停用户线程，就意味着期间会不断有垃圾产生，永远也清理不干净。其次，用户线程的运行必然会导致对象的引用关系发生改变，这就会导致两种情况："),s("strong",[a._v("漏标")]),a._v(" 和 "),s("strong",[a._v("错标")]),a._v("。")]),a._v(" "),s("h4",{attrs:{id:"漏标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#漏标"}},[a._v("#")]),a._v(" 漏标")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("B")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2.")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("C")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("C")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3.")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("C")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),a._v("；\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4.")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("C")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("C")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("ol",[s("li",[a._v("根据上述代码，仅仅在第1、2步时，状态：黑色->灰色->白色， 如下图")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/rule-liu/pic/raw/master/img/20211018141028.png",alt:""}})]),a._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[a._v("如果一切顺利，不发生任何引用变化，GC线程顺着灰色的引用向下扫描,最后都变成黑色，都是存活对象。")]),a._v(" "),s("li",[a._v("但是如果出现了这样一个状况，在扫描到灰色的时候，还没有扫描到这个白色对象，此时，黑色对象引用了这个白色对象，而灰色对象指向了别的对象，或者干脆指向了null，也就是取消了对白色对象的引用。（代码中的3，4步），如下图")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/rule-liu/pic/raw/master/img/20211018140817.png",alt:""}})]),a._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[a._v("根据三色标记的规则，GC 会认为黑色对象是已经扫描过的了，不会再对A指向的对象进行扫描，也就不会扫描到C白色对象，最后结果就是,白色对象直到本次标记扫描结束,也是白色,根据三色标记规则,认为它是垃圾,被清理掉。\n"),s("img",{attrs:{src:"https://gitee.com/rule-liu/pic/raw/master/img/20211018141136.png",alt:""}})])]),a._v(" "),s("h3",{attrs:{id:"_4-解决三色标记的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-解决三色标记的问题"}},[a._v("#")]),a._v(" 4. 解决三色标记的问题")]),a._v(" "),s("p",[a._v("上面的漏标问题，就会导致对象被错误的回收了，漏标的两个必要条件：")]),a._v(" "),s("ul",[s("li",[a._v("有至少一个黑色对象在自己被标记之后指向这个白色对象。")]),a._v(" "),s("li",[a._v("所有的灰色对象在自己引用扫描完成之前删除了对白色对象的引用。")])]),a._v(" "),s("h4",{attrs:{id:"cms-增量更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cms-增量更新"}},[a._v("#")]),a._v(" CMS 增量更新")]),a._v(" "),s("p",[a._v("增量更新破坏的是第一个条件,我们在这个黑色对象增加了对白色对象的引用之后,将它的这个引用,记录下来,在最后标记的时候,再以这个黑色对象为根,对它的引用进行重新扫描。\n可以简单理解为,当一个黑色对象增加了对白色对象的引用,那么这个黑色对象就被变灰。\n这样有一个缺点,就是会重新扫描这个黑色对象的所有引用,比较浪费时间。")]),a._v(" "),s("h4",{attrs:{id:"g1-原始快照-satb"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#g1-原始快照-satb"}},[a._v("#")]),a._v(" G1 原始快照 （SATB）")]),a._v(" "),s("p",[a._v("原始快照破坏的是第二个条件,我们在这个灰色对象取消对白色对象的引用之前,将这个引用记录下来,在最后标记的时候,再以这个引用指向的白色对象为根,对它的引用进行扫描。可以简单理解为,当一个灰色对象取消了对白色对象的引用,那么这个白色对象被变灰。")]),a._v(" "),s("p",[a._v("这样做的缺点就是,这个白色对象有可能并没有黑色对象去引用它,但是它还是被变灰了,就会导致它和它的引用,本来应该被垃圾回收掉,但是此次GC存活了下来,就是所谓的浮动垃圾.其实这样是比较可以忍受的,只是让它多存活了一次GC而已,浪费一点点空间,但是会比增量更新更省时间。")]),a._v(" "),s("h3",{attrs:{id:"为什么g1用satb-cms用增量更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么g1用satb-cms用增量更新"}},[a._v("#")]),a._v(" 为什么G1用SATB？CMS用增量更新？")]),a._v(" "),s("p",[a._v("原始快照相对增量更新效率会高(可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象（黑色对象新插入白色对象或灰色对象的引用）而且G1 针对的是大内存的环境下，深度扫描会导致时间更久了，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。")])])}),[],!1,null,null,null);t.default=e.exports}}]);