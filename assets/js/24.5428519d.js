(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{384:function(l,e,t){"use strict";t.r(e);var a=t(42),r=Object(a.a)({},(function(){var l=this,e=l.$createElement,t=l._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[t("h3",{attrs:{id:"垃圾收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[l._v("#")]),l._v(" 垃圾收集器")]),l._v(" "),t("p",[l._v("上篇介绍了垃圾回收的算法，那么在垃圾收集器中是怎么使用这些算法的呢？")]),l._v(" "),t("h4",{attrs:{id:"新生代垃圾收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代垃圾收集器"}},[l._v("#")]),l._v(" 新生代垃圾收集器")]),l._v(" "),t("ul",[t("li",[l._v("Serial 垃圾收集器（单线程）\n垃圾收集过程中，只开启一条 GC 线程，并且其他线程必须暂停。当前的线程一心一意的只负责收集垃圾，避免了线程切换的开销，简单效率明显，这种收集器只适合客户端使用。")])]),l._v(" "),t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/01/27/J82eWbuMKxrlaSN.png",alt:"image.png"}})]),l._v(" "),t("ul",[t("li",[t("p",[l._v("ParNew 垃圾收集器（多线程）\nParNew 是 Serial 的多线程版本，由多条 GC 线程并行地进行垃圾清理。但是清理的过程中，依然会 Stop The World。\n这种收集器在线程少的情况比起 Serial 来说，收集效率会下降，因为增加了线程切换的开销。\n"),t("img",{attrs:{src:"https://i.loli.net/2021/01/27/Ibmlf1WhRYL6qkU.png",alt:"image.png"}})])]),l._v(" "),t("li",[t("p",[l._v("Parallel Scavenge 垃圾收集器（多线程）\n它与 ParNew 一样，都是多线程收集器，但是它们的核心宗旨不一样：")]),l._v(" "),t("ul",[t("li",[l._v("ParNew：追求的用户低停顿的时间")]),l._v(" "),t("li",[l._v("Parallel Scavenge：追求CPU的吞吐量，能够在较短时间内完成指定任务；吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）\n追求高吞吐量，可以通过减少 GC 执行实际工作的时间，然而，仅仅偶尔运行 GC 意味着每当 GC 运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。单个 GC 需要花更多的时间来完成，从而导致更高的暂停时间。而考虑到低暂停时间，最好频繁运行 GC 以便更快速完成，反过来又导致吞吐量下降。")])])])]),l._v(" "),t("h4",{attrs:{id:"老年代垃圾收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#老年代垃圾收集器"}},[l._v("#")]),l._v(" 老年代垃圾收集器")]),l._v(" "),t("ul",[t("li",[t("p",[l._v("Serial Old 垃圾收集器（单线程）\nSerial Old 收集器是 Serial 的老年代版本，都是单线程收集器，只启用一条 GC 线程，都适合客户端应用。它们唯一的区别就是：Serial Old 工作在老年代，使用“标记-整理”算法；Serial 工作在新生代，使用“复制”算法。")])]),l._v(" "),t("li",[t("p",[l._v("Parallel Old 垃圾收集器（多线程）\nParallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。")])]),l._v(" "),t("li",[t("p",[l._v("CMS 垃圾收集器\nCMS(Concurrent Mark Sweep，并发标记清除)收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。")]),l._v(" "),t("ul",[t("li",[l._v("初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记，速度很快。")]),l._v(" "),t("li",[l._v("并发标记：使用多条标记线程，从 GC Roots 的直接关联的对象开始进行标记，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。")]),l._v(" "),t("li",[l._v("重新标记：Stop The World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。")]),l._v(" "),t("li",[l._v("并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。")])]),l._v(" "),t("p",[l._v("并发标记与并发清除过程耗时最长，且可以与用户线程一起工作，因此，总体上说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。\n"),t("img",{attrs:{src:"https://i.loli.net/2021/01/27/8FYpys4q1KJPt2g.png",alt:"image.png"}}),l._v("\nCMS的缺点：")]),l._v(" "),t("ul",[t("li",[l._v("吞吐量低")]),l._v(" "),t("li",[l._v("无法处理浮动垃圾，导致频繁 Full GC")]),l._v(" "),t("li",[l._v("使用“标记-清除”算法产生碎片空间")])]),l._v(" "),t("p",[l._v("对于产生碎片空间的问题，可以通过开启 -XX:+UseCMSCompactAtFullCollection，在每次 Full GC 完成后都会进行一次内存压缩整理，将零散在各处的对象整理到一块。设置参数 -XX:CMSFullGCsBeforeCompaction 告诉 CMS，经过了 N 次 Full GC 之后再进行一次内存整理。")])])]),l._v(" "),t("h4",{attrs:{id:"g1-通用垃圾收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1-通用垃圾收集器"}},[l._v("#")]),l._v(" G1 通用垃圾收集器")]),l._v(" "),t("p",[l._v("G1 是一款面向服务端应用的垃圾收集器，它没有新生代和老年代的概念，而是将堆划分为一块块独立的大小相等的 Region。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。\n从整体上看， G1 是基于“标记-整理”算法实现的收集器，从局部（两个 Region 之间）上看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。")]),l._v(" "),t("p",[l._v("一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？\n并不！每个 Region 都有一个 Remembered Set，用于记录别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。记忆集本质是一种 Hash 表， Key 是别的 Region 区域的起始地址，Value 是一个集合，存储的元素是卡表的索引号。这种卡表结构是双向的，（卡表结构：我指向谁，谁指向我）然后对这些区域进行可达性分析，这样就避免了整堆扫描")]),l._v(" "),t("p",[l._v("如果不计算维护 Remembered Set 的操作，G1 收集器的工作过程分为以下几个步骤：")]),l._v(" "),t("ul",[t("li",[l._v("初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。")]),l._v(" "),t("li",[l._v("并发标记：使用一条标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。")]),l._v(" "),t("li",[l._v("最终标记：Stop The World，使用多条标记线程并发执行。")]),l._v(" "),t("li",[l._v("筛选回收：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);