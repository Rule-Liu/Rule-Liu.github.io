(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{374:function(n,e,t){"use strict";t.r(e);var a=t(42),s=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"简单工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂模式"}},[n._v("#")]),n._v(" 简单工厂模式")]),n._v(" "),t("h4",{attrs:{id:"定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[n._v("#")]),n._v(" 定义")]),n._v(" "),t("p",[n._v("实例化对象的时候不再使用 new Object()形式，可以根据用户的选择条件来实例化相关的类。对于客户端来说，\n去除了具体的类的依赖。只需要给出具体实例的描述给工厂，工厂就会自动返回具体的实例对象。\n工厂的意思可以理解为一个兵工厂中，可以生产多种武器，包括：手枪、步枪、狙击枪等。\n但是这些类型的枪又属于枪的子类。如果不采用简单工厂的设计模式，采取最原始的模式就是：\n分别新建三个子类，Pistol（手枪类），Rifle（步枪），Snipe（狙击枪）。它们都有共同的属性，\n例如子弹直径（diameter），射速(shootSpeed)，还有公共的方法shoot（射击）方法等。\n那么就会在三个类中出现重复的属性。当然你会想到新建一个基类Gun（枪类），\n将公共的属性都添加到这个基类中，然后其他的子类就继承这个基类。这样做当然就解决了代码冗余的问题。\n但是这样起不到一个统一管理的目的。用户不知道该去实例化那个对象，将来会不会增加实例化的对象。\n那么到现在就应该考虑用一个单独的类来做创造实例的过程，这就是工厂。")]),n._v(" "),t("h4",{attrs:{id:"具体实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具体实现"}},[n._v("#")]),n._v(" 具体实现")]),n._v(" "),t("ul",[t("li",[n._v("先新建一个Gun（枪类）基类：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n* @description: 枪基类\n* @author: rule\n* @date: 2019-06-30 22:45\n**/\npublic class Gun {\n\n    /**\n     * 枪名\n     */\n    private String gunName;\n\n    /**\n     * 子弹直径\n     */\n    private double diameter;\n\n    /**\n     * 射速\n     */\n    private double shootSpeed;\n\n    /**\n     * 射击方法\n     */\n    public void Shoot () {\n        System.out.println("这里所有枪都可以射击");\n    }\n}\n')])])]),t("ul",[t("li",[n._v("分别新建三个枪的子类：Pistol（手枪类）、Rifle（步枪类）、Snipe（狙击枪类）")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n* @description: 手枪类\n* @author: rule\n* @date: 2019-06-30 22:54\n**/\npublic class Pistol extends Gun {\n\n    @Override\n    public void Shoot() {\n        System.out.println("这把" + getGunName() + "手枪" + "，子弹直径为" + getDiameter() + "mm，射速为" + getShootSpeed() + "km/s");\n    }\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n* @description: 步枪类\n* @author: rule\n* @date: 2019-06-30 22:55\n**/\npublic class Rifle extends Gun {\n\n    @Override\n    public void Shoot() {\n        System.out.println("这把" + getGunName() + "步枪" + "，子弹直径为" + getDiameter() + "mm，射速为" + getShootSpeed() + "km/s");\n    }\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n* @description: 狙击枪类\n* @author: rule\n* @date: 2019-06-30 22:55\n**/\npublic class Snipe extends Gun {\n\n    @Override\n    public void Shoot() {\n        System.out.println("这把" + getGunName() + "狙击枪" + "，子弹直径为" + getDiameter() + "mm，射速为" + getShootSpeed() + "km/s");\n    }\n}\n')])])]),t("ul",[t("li",[n._v("新建GunFactory（兵工厂类）")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n* @description: 枪工厂\n* @author: rule\n* @date: 2019-06-30 22:51\n**/\npublic class GunFactory {\n\n    public static Gun createGun(String  gunName) {\n        Gun gun = null;\n        if (gunName.equals("Pistol")) {\n            gun = new Pistol();\n        }else if (gunName.equals("Rifle")) {\n            gun = new Rifle();\n        }else if (gunName.equals("Snipe")) {\n            gun = new Snipe();\n        }\n        return gun;\n    }\n}\n')])])]),t("h4",{attrs:{id:"简单工厂模式测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂模式测试"}},[n._v("#")]),n._v(" 简单工厂模式测试")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n* @description: 兵工厂测试类\n* @author: rule\n* @date: 2019-06-30 23:29\n**/\npublic class GunFactoryTest {\n\n    public static void main(String[] args) {\n        Gun gun = null;\n        gun = GunFactory.createGun("Pistol");\n        gun.setGunName("沙鹰");\n        gun.setDiameter(3);\n        gun.setShootSpeed(60);\n        gun.Shoot();\n    }\n}\n')])])]),t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/02/12/bwmcH6NEuTnUfAo.png",alt:"image.png"}})]),n._v(" "),t("h4",{attrs:{id:"优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[n._v("#")]),n._v(" 优缺点")]),n._v(" "),t("p",[n._v("根据上述的测试例子，相信大家都对简单工厂模式有了基本的了解，先谈谈它的优缺点：")]),n._v(" "),t("ol",[t("li",[n._v("简单工厂使用了java中的继承、封装、多态特性，决定兵工厂的生产什么类型的枪的决定权交到了用户的手中。根据用户自己的需要，生成合适的枪类。")]),n._v(" "),t("li",[n._v("模块分明，起到了可维护性。当然，缺点也是存在的，当我需要增加冲锋枪类时，需要新建子类去继承基类，然后再去修改兵工厂中的createGun方法，这其实就使得代码的结构出现了高耦合了，因为我修改一个子类，最坏的情况是要修改自己类和兵工厂的类。\n这样其实也没有做到“高内聚-低耦合”的设计原则。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);