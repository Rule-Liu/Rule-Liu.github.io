(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{371:function(e,n,t){"use strict";t.r(n);var a=t(42),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"简单工厂-抽象工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂-抽象工厂模式"}},[e._v("#")]),e._v(" 简单工厂+抽象工厂模式")]),e._v(" "),t("h4",{attrs:{id:"定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),t("p",[e._v("该模式主要是用来解决抽象工厂模式代码冗余的部分，取消掉抽象工厂接口和具体工厂类，使用简单工厂模式，在SimpleFactory中，根据给定的条件选择创建具体产品")]),e._v(" "),t("h4",{attrs:{id:"结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[e._v("#")]),e._v(" 结构")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/02/12/3M4qJGinaQpx9ST.png",alt:"image.png"}})]),e._v(" "),t("h4",{attrs:{id:"具体实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#具体实现"}},[e._v("#")]),e._v(" 具体实现")]),e._v(" "),t("p",[e._v("通过SimpleFactory（简单工厂类）可以看出，每次构造产品，都需要指定factoryName，否则无法判断选择哪一个工厂进行生产")]),e._v(" "),t("ul",[t("li",[e._v("SimpleFactory（简单工厂类）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/**\n* @description: 手机简单工厂\n* @author: rule\n* @date: 2019-07-21 18:48\n**/\npublic class PhoneSimpleFactory {\n    private static final String factoryName = "apple";\n    public ISmartPhone createPhone() {\n        ISmartPhone smartPhone = null;\n        switch (factoryName) {\n            case "apple":\n                smartPhone = new ApplePhone();\n                break;\n            case "samsung":\n                smartPhone = new SamsungPhone();\n                break;\n        }\n        return smartPhone;\n    }\n\n    public IChip createChip() {\n        IChip chip = null;\n        switch (factoryName) {\n            case "apple":\n                chip = new AppleChip();\n                break;\n            case "samsung":\n                chip = new SamsungChip();\n                break;\n        }\n        return chip;\n    }\n}\n')])])]),t("ul",[t("li",[t("p",[e._v("AbstractProduct接口（智能手机和芯片接口）")])]),e._v(" "),t("li",[t("p",[e._v("具体工厂类（BasketBallFactory、FootBallFactory和VolleyBallFactory）")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n* @description: 智能手机接口\n* @author: rule\n* @date: 2019-07-20 21:43\n**/\npublic interface ISmartPhone {\n\n    /**\n     * 展示最新手机\n     */\n    void showNewestPhone();\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n* @description: 芯片接口\n* @author: rule\n* @date: 2019-07-20 21:57\n**/\npublic interface IChip {\n\n    /**\n     * 展示最新芯片\n     */\n    void showNewestChip();\n}\n")])])]),t("ul",[t("li",[e._v("ConcreteProduct实现类（苹果手机、芯片和三星手机和芯片实现类）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/**\n* @description: 苹果智能手机\n* @author: rule\n* @date: 2019-07-20 21:44\n**/\npublic class ApplePhone implements ISmartPhone {\n    @Override\n    public void showNewestPhone() {\n        System.out.println("苹果今年最新的手机是IphoneX1");\n    }\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/**\n* @description: 苹果芯片\n* @author: rule\n* @date: 2019-07-20 21:58\n**/\npublic class AppleChip implements IChip {\n    @Override\n    public void showNewestChip() {\n        System.out.println("苹果今年最新的芯片是A12X");\n    }\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/**\n* @description: 三星智能手机类\n* @author: rule\n* @date: 2019-07-20 21:44\n**/\npublic class SamsungPhone implements ISmartPhone {\n\n   @Override\n   public void showNewestPhone() {\n       System.out.println("三星今年最新的手机是SamsungS10");\n   }\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/**\n* @description: 三星芯片\n* @author: rule\n* @date: 2019-07-20 21:58\n**/\npublic class SamsungChip implements IChip {\n\n   @Override\n   public void showNewestChip() {\n       System.out.println("三星今年最新的芯片是晓龙855");\n   }\n}\n')])])]),t("h4",{attrs:{id:"简单-抽象测试类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单-抽象测试类"}},[e._v("#")]),e._v(" 简单+抽象测试类")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n* @description: 简单+抽象工厂测试类\n* @author: rule\n* @date: 2019-07-21 18:55\n**/\npublic class SimpleAbstractTest {\n    public static void main(String[] args) {\n        PhoneSimpleFactory simpleFactory = new PhoneSimpleFactory();\n        ISmartPhone smartPhone = simpleFactory.createPhone();\n        smartPhone.showNewestPhone();\n    }\n}\n")])])]),t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/02/12/qLwNTJbYAgVpzG1.png",alt:"image.png"}})]),e._v(" "),t("h4",{attrs:{id:"优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[e._v("#")]),e._v(" 优缺点")]),e._v(" "),t("ul",[t("li",[e._v("优点：")])]),e._v(" "),t("ol",[t("li",[e._v("减少了抽象工厂和具体工厂之间的代码。")]),e._v(" "),t("li",[e._v("选择简单工厂模式来管理，如果新增产品的情况下，只需要改变SimpleFactory类即可，不需要像原来一样修改多个类。")])]),e._v(" "),t("ul",[t("li",[e._v("缺点：")])]),e._v(" "),t("ol",[t("li",[e._v("在简单工厂类中需要进行判断，才能得出需要创建那个工厂，需要修改factoryName才行。")]),e._v(" "),t("li",[e._v("不符合“ 开放-封闭”原则。")])]),e._v(" "),t("h4",{attrs:{id:"改进-反射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#改进-反射"}},[e._v("#")]),e._v(" 改进（反射）")]),e._v(" "),t("ul",[t("li",[e._v("config.xml（工厂配置文件）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<?xml version="1.0"?>\n<config>\n    <className>com.rule.factory.proimpl.SamsungPhone</className>\n</config>\n')])])]),t("ul",[t("li",[e._v("ReflectFactory（反射工厂类）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/**\n* @description: 手机反射工厂\n* @author: rule\n* @date: 2019-07-21 19:37\n**/\npublic class PhoneReflectFactory {\n\n    public static Object getBean() {\n        try {\n            //创建文档对象\n            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = dFactory.newDocumentBuilder();\n            Document doc;\n            doc = builder.parse(new File("simple-abstract-pattern/src/resources/config.xml"));\n            //获取包含类名的文本节点\n            NodeList nl = doc.getElementsByTagName("className");\n            Node classNode = nl.item(0).getFirstChild();\n            String cName = classNode.getNodeValue();\n            //通过类名生成实例对象并将其返回\n            Class c = Class.forName(cName);\n            Object obj = c.newInstance();\n            return obj;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public ISmartPhone createPhone() {\n        ISmartPhone smartPhone = null;\n        smartPhone = (ISmartPhone) getBean();\n        return smartPhone;\n    }\n\n    public IChip createChip() {\n        IChip chip = null;\n        chip = (IChip) getBean();\n        return chip;\n    }\n}\n')])])]),t("ul",[t("li",[e._v("SimpleAbstractTest（简单抽象测试类）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/**\n* @description: 简单+抽象工厂测试类\n* @author: rule\n* @date: 2019-07-21 18:55\n**/\npublic class SimpleAbstractTest {\n\n    public static void main(String[] args) {\n        PhoneSimpleFactory simpleFactory = new PhoneSimpleFactory();\n        ISmartPhone smartPhone = simpleFactory.createPhone();\n        smartPhone.showNewestPhone();\n        System.out.println("======下面使用反射创建工厂=======");\n        PhoneReflectFactory reflectFactory = new PhoneReflectFactory();\n        reflectFactory.createPhone().showNewestPhone();\n    }\n}\n')])])]),t("blockquote",[t("p",[e._v("使用反射解决了简单工厂模式每次新增产品时，都需要添加switch-case的条件，基本做到了“开放-封闭”的设计原则，但是这种方法比较复杂，需要对反射有一定的了解和解析xml文件才能实现")])])])}),[],!1,null,null,null);n.default=s.exports}}]);