(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{400:function(e,n,r){"use strict";r.r(n);var t=r(42),o=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"threadpool-分析-下"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#threadpool-分析-下"}},[e._v("#")]),e._v(" ThreadPool - 分析-下")]),e._v(" "),r("p",[e._v("上一篇文章已经分析了线程池的核心方法，但是核心方法中的具体细节还没有分析，接下来就分析下")]),e._v(" "),r("h5",{attrs:{id:"具体执行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#具体执行"}},[e._v("#")]),e._v(" 具体执行")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("boolean addWorker(Runnable firstTask, boolean core)")]),e._v("：添加任务到队列中，如果添加成功后，执行任务。\n参数 firstTask：可以为空，那么表示执行队列中的对头任务执行，否则根据核心数的条件判断是否新建线程执行还是加入队列\n参数 core：是否使用核心线程数，如果是true，则根据 corePoolSize，否则使用 maximumPoolSize")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("   private boolean addWorker(Runnable firstTask, boolean core) {\n       retry:\n       for (;;) {\n           int c = ctl.get();\n           int rs = runStateOf(c);\n   \n           // 这个非常不好理解\n           // 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：\n           // 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED\n           // 2. firstTask != null\n           // 3. workQueue.isEmpty()\n           // 简单分析下：\n           // 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行\n           // 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务\n           // 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的\n           // 这是因为 SHUTDOWN 的语义：不允许提交新的任务，但是要把已经进入到 workQueue 的任务执行完，\n           // 所以在满足条件的基础上，是允许创建新的 Worker 的\n           if (rs >= SHUTDOWN &&\n               ! (rs == SHUTDOWN &&\n                  firstTask == null &&\n                  ! workQueue.isEmpty()))\n               return false;\n   \n           for (;;) {\n               int wc = workerCountOf(c);\n               if (wc >= CAPACITY ||\n                   wc >= (core ? corePoolSize : maximumPoolSize))\n                   return false;\n               // 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了\n               // 这里失败的话，说明有其他线程也在尝试往线程池中创建线程\n               if (compareAndIncrementWorkerCount(c))\n                   break retry;\n               // 由于有并发，重新再读取一下 ctl\n               c = ctl.get();\n               // 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了 \n               // 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池\n               // 那么需要回到外层的for循环\n               if (runStateOf(c) != rs)\n                   continue retry;\n               // else CAS failed due to workerCount change; retry inner loop\n           }\n       }\n   \n       /*\n        * 到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了，\n        * 因为该校验的都校验了，至于以后会发生什么，那是以后的事，至少当前是满足条件的\n        */\n       // worker 是否已经启动\n       boolean workerStarted = false;\n       // 是否已将这个 worker 添加到 workers 这个 HashSet 中\n       boolean workerAdded = false;\n       Worker w = null;\n       try {\n           final ReentrantLock mainLock = this.mainLock;\n           // 把 firstTask 传给 worker 的构造方法\n           w = new Worker(firstTask);\n           // 取 worker 中的线程对象，之前说了，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程\n           final Thread t = w.thread;\n           if (t != null) {\n               // 这个是整个线程池的全局锁，持有这个锁才能让下面的操作“顺理成章”，\n               // 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭\n               mainLock.lock();\n               try {\n                   int c = ctl.get();\n                   int rs = runStateOf(c);\n   \n                   // 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况\n                   // 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务\n                   if (rs < SHUTDOWN ||\n                       (rs == SHUTDOWN && firstTask == null)) {\n                       // worker 里面的 thread 可不能是已经启动的\n                       if (t.isAlive())\n                           throw new IllegalThreadStateException();\n                       // 加到 workers 这个 HashSet 中\n                       workers.add(w);\n                       int s = workers.size();\n                       // largestPoolSize 用于记录 workers 中的个数的最大值\n                       // 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值\n                       if (s > largestPoolSize)\n                           largestPoolSize = s;\n                       workerAdded = true;\n                   }\n               } finally {\n                   mainLock.unlock();\n               }\n               // 添加成功的话，启动这个线程\n               if (workerAdded) {\n                   // 启动线程\n                   t.start();\n                   workerStarted = true;\n               }\n           }\n       } finally {\n           // 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉\n           if (! workerStarted)\n               addWorkerFailed(w);\n       }\n       // 返回线程是否启动成功\n       return workerStarted;\n   }\n")])])]),r("p",[e._v("添加失败的话，会将加入workers 中的 worker 进行移除，可以看下面这个方法："),r("code",[e._v("addWorkerFailed(Worker w)")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// workers 中删除掉相应的 worker\n// workCount 减 1\nprivate void addWorkerFailed(Worker w) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        if (w != null)\n            workers.remove(w);\n        decrementWorkerCount();\n        // rechecks for termination, in case the existence of this worker was holding up termination\n        tryTerminate();\n    } finally {\n        mainLock.unlock();\n    }\n}\n")])])]),r("p",[e._v("添加成功的话，根据 "),r("code",[e._v("addWorker(Runnable firstTask, boolean core)")]),e._v(" 中代码，就会执行 t.start(), start() 方法具体执行的逻辑就是\nrun() 方法中的，那么接下来继续看 worker.run() 方法")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("public void run() {\n    // 执行的具体方法\n   runWorker(this);\n }\n\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        // 任务不为空，或者 getTask() 不为空，\n        // getTask() 就是 从 workQueue 队列中取出先入队的任务\n        // 循环调用 getTask 获取任务 ，下面会详细将这块 getTask()\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n             // 如果线程池状态大于等于 STOP，那么意味着该线程也要中断\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                // 这是一个钩子方法，留给需要的子类实现\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    // 执行任务\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                     // 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                 // 置空 task，准备 getTask 获取下一个任务\n                task = null;\n                // 累加完成的任务数\n                w.completedTasks++;\n                // 释放掉 worker 的独占锁\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n         // 如果到这里，需要执行线程关闭：\n        // 1. 说明 getTask 返回 null，也就是说，队列中已经没有任务需要执行了，执行关闭\n        // 2. 任务执行过程中发生了异常\n        // 第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中会说\n        // 第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n")])])]),r("p",[e._v("接下里看下 getTask() 怎么从阻塞队列中获取任务的")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 执行阻塞或定时等待任务，具体取决于当前配置设置，如果返回null，因为那么下列任何一个原因：\n//1. 超过了maximumPoolSize 的 workers\n//2. 线程池是停止的\n//3. 线程池是关闭的或者队列是空的\n//4.worker 执行任务超时了\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // 检查队列是否是空的，或者线程状态是错误的\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            // CAS 减少一个 worker 数\n            decrementWorkerCount();\n            return null;\n        }\n\n        int wc = workerCountOf(c);\n\n        //允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n         // wc <= maximumPoolSize 同时没有超时\n        try {\n             // 到 workQueue 中获取任务\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            // 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，\n             // 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null\n            timedOut = false;\n        }\n    }\n}\n")])])]),r("h3",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),r("ul",[r("li",[e._v("java 线程池有哪些关键属性？")])]),e._v(" "),r("blockquote",[r("p",[e._v("corePoolSize，maximumPoolSize，workQueue，keepAliveTime，rejectedExecutionHandler\ncorePoolSize 到 maximumPoolSize 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。\nworkQueue 用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务。\nkeepAliveTime 用于设置空闲时间，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作\nrejectedExecutionHandler 用于处理当线程池不能执行此任务时的情况，默认有抛出 RejectedExecutionException 异常、忽略任务、\n使用提交任务的线程来执行此任务和将队列中等待最久的任务删除，然后提交此任务这四种策略，默认为抛出异常。")])]),e._v(" "),r("ul",[r("li",[e._v("说说线程池中的线程创建时机？")])]),e._v(" "),r("blockquote",[r("ul",[r("li",[e._v("如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；")]),e._v(" "),r("li",[e._v("如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；")]),e._v(" "),r("li",[e._v("如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了\nmaximumPoolSize，那么执行拒绝策略。")])])]),e._v(" "),r("blockquote",[r("p",[e._v("注意：如果将队列设置为无界队列，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了。\n因为后面的任务直接往队列塞就行了，此时 maximumPoolSize 参数就没有什么意义。")])]),e._v(" "),r("ul",[r("li",[e._v("任务执行过程中发生异常怎么处理？")])]),e._v(" "),r("blockquote",[r("p",[e._v("如果某个任务执行出现异常，那么执行任务的线程会被关闭，而不是继续接收其他任务。然后会启动一个新的线程来代替它。")])]),e._v(" "),r("ul",[r("li",[e._v("什么时候会执行拒绝策略？")])]),e._v(" "),r("blockquote",[r("ul",[r("li",[e._v("workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。")]),e._v(" "),r("li",[e._v("workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。")])])])])}),[],!1,null,null,null);n.default=o.exports}}]);