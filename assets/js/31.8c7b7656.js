(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{388:function(t,a,s){"use strict";s.r(a);var r=s(42),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"垃圾收集器过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器过程"}},[t._v("#")]),t._v(" 垃圾收集器过程")]),t._v(" "),s("h2",{attrs:{id:"cms"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cms"}},[t._v("#")]),t._v(" CMS")]),t._v(" "),s("h3",{attrs:{id:"初始标记-stw"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始标记-stw"}},[t._v("#")]),t._v(" 初始标记 (STW)")]),t._v(" "),s("ul",[s("li",[t._v("仅仅只是标记一下GC Roots直接能引用的对象，\n这个过程速度是很快，GC Roots：对各个线程栈内存中的局部变量，以及方法区中的类静态变量")])]),t._v(" "),s("h3",{attrs:{id:"并发标记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发标记"}},[t._v("#")]),t._v(" 并发标记")]),t._v(" "),s("ul",[s("li",[t._v("允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象")])]),t._v(" "),s("h3",{attrs:{id:"重新标记-stw"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重新标记-stw"}},[t._v("#")]),t._v(" 重新标记 (STW)")]),t._v(" "),s("ul",[s("li",[t._v("系统程序是禁止运行的，但是会根据并发标记阶段记录的那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象")])]),t._v(" "),s("h3",{attrs:{id:"并发清理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发清理"}},[t._v("#")]),t._v(" 并发清理")]),t._v(" "),s("ul",[s("li",[t._v("并发将上一步标记的对象进行整理在一起，然后一起清除，减少内存碎片")])]),t._v(" "),s("h2",{attrs:{id:"g1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#g1"}},[t._v("#")]),t._v(" G1")]),t._v(" "),s("h3",{attrs:{id:"使用-xx-useg1gc-指定g1垃圾回收器-每个region-的大小为用堆大小除以2048-最多有2048个region-并且region大小为2的倍数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用-xx-useg1gc-指定g1垃圾回收器-每个region-的大小为用堆大小除以2048-最多有2048个region-并且region大小为2的倍数"}},[t._v("#")]),t._v(" 使用 “-XX:+UseG1GC”，指定G1垃圾回收器，每个region 的大小为用堆大小除以2048，最多有2048个region，并且region大小为2的倍数")]),t._v(" "),s("h3",{attrs:{id:"分为新生代和老年代-新生代最多占总比的60-同样也有-eden-和-survivor-区。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分为新生代和老年代-新生代最多占总比的60-同样也有-eden-和-survivor-区。"}},[t._v("#")]),t._v(" 分为新生代和老年代，新生代最多占总比的60%，同样也有 Eden 和 Survivor 区。")]),t._v(" "),s("h3",{attrs:{id:"g1-进行年轻代垃圾回收时-可以设置目标gc停顿的时间-通过-xx-maxgcpausemills-默认为200ms"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#g1-进行年轻代垃圾回收时-可以设置目标gc停顿的时间-通过-xx-maxgcpausemills-默认为200ms"}},[t._v("#")]),t._v(" G1 进行年轻代垃圾回收时，可以设置目标GC停顿的时间，通过 -XX:MaxGCPauseMills，默认为200ms")]),t._v(" "),s("h2",{attrs:{id:"g1触发进入老年代机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#g1触发进入老年代机制"}},[t._v("#")]),t._v(" G1触发进入老年代机制")]),t._v(" "),s("h3",{attrs:{id:"基本和原来的机制一致-除了大对象进入老年代"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本和原来的机制一致-除了大对象进入老年代"}},[t._v("#")]),t._v(" 基本和原来的机制一致，除了大对象进入老年代")]),t._v(" "),s("h3",{attrs:{id:"大对象的判定规则就是一个大对象超过了一个region大小的50-一个对象太大-则会横跨多个region-存放。新生代、老年代在回收的时候-会顺带带着大对象region一起回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#大对象的判定规则就是一个大对象超过了一个region大小的50-一个对象太大-则会横跨多个region-存放。新生代、老年代在回收的时候-会顺带带着大对象region一起回收"}},[t._v("#")]),t._v(" 大对象的判定规则就是一个大对象超过了一个Region大小的50%，一个对象太大，则会横跨多个Region 存放。新生代、老年代在回收的时候，会顺带带着大对象Region一起回收")]),t._v(" "),s("h2",{attrs:{id:"触发新生代-老年代的混合垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#触发新生代-老年代的混合垃圾回收机制"}},[t._v("#")]),t._v(" 触发新生代+老年代的混合垃圾回收机制")]),t._v(" "),s("h3",{attrs:{id:"老年代占据了堆内存的45-的region的时候-此时就会尝试触发一个新生代-老年代一起回收的混合回收阶段-xx-initiatingheapoccupancypercent-默认值是45"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#老年代占据了堆内存的45-的region的时候-此时就会尝试触发一个新生代-老年代一起回收的混合回收阶段-xx-initiatingheapoccupancypercent-默认值是45"}},[t._v("#")]),t._v(" 老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段，-XX:InitiatingHeapOccupancyPercent，默认值是45%")]),t._v(" "),s("h2",{attrs:{id:"g1-回收过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#g1-回收过程"}},[t._v("#")]),t._v(" G1 回收过程")]),t._v(" "),s("h3",{attrs:{id:"初始标记-stw-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始标记-stw-2"}},[t._v("#")]),t._v(" 初始标记 (STW)")]),t._v(" "),s("ul",[s("li",[t._v("仅仅只是标记一下GC Roots直接能引用的对象，\n这个过程速度是很快，GC Roots：对各个线程栈内存中的局部变量，以及方法区中的类静态变量")])]),t._v(" "),s("h3",{attrs:{id:"并发标记-耗时-会追踪全部对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发标记-耗时-会追踪全部对象"}},[t._v("#")]),t._v(" 并发标记（耗时，会追踪全部对象）")]),t._v(" "),s("ul",[s("li",[t._v("允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象")])]),t._v(" "),s("h3",{attrs:{id:"最终标记-stw"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最终标记-stw"}},[t._v("#")]),t._v(" 最终标记 (STW)")]),t._v(" "),s("ul",[s("li",[t._v("系统程序是禁止运行的，但是会根据并发标记阶段记录的那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象")])]),t._v(" "),s("h3",{attrs:{id:"混合回收-stw"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合回收-stw"}},[t._v("#")]),t._v(" 混合回收(STW)")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("计算老年代中每个Region中的存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。接着会停止系统程序，然后全力以赴尽快进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在指定的范围内")]),t._v(" "),s("ul",[s("li",[t._v("是允许执行多次混合回收,“-XX:G1MixedGCCountTarget”参数，就是在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次。一旦空闲出来的Region数量达到了堆内存的5%，此时就会 立即停止混合回收，“-XX:G1HeapWastePercent”，默认值是5%“-XX:G1MixedGCLiveThresholdPercent”，默认值是85%，意思就是确定要回收的Region的时候，必须是存活对象低于85%的Region才可以进行回收")])])])])])}),[],!1,null,null,null);a.default=e.exports}}]);