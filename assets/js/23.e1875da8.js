(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{381:function(v,_,t){"use strict";t.r(_);var a=t(42),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"类文件结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类文件结构"}},[v._v("#")]),v._v(" 类文件结构")]),v._v(" "),t("h4",{attrs:{id:"jvm的无关性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm的无关性"}},[v._v("#")]),v._v(" JVM的无关性")]),v._v(" "),t("ul",[t("li",[v._v("平台无关性：任何操作系统都能运行Java代码")]),v._v(" "),t("li",[v._v("语言无关性：JVM能运行除Java以外的其他代码")])]),v._v(" "),t("p",[v._v("Java 源代码首先需要使用 Javac 编译器编译成 .class 文件，然后由 JVM 执行 .class 文件，从而程序开始运行。")]),v._v(" "),t("h4",{attrs:{id:"class文件结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class文件结构"}},[v._v("#")]),v._v(" Class文件结构")]),v._v(" "),t("p",[v._v("Class 文件是二进制文件，它的内容具有严格的规范，文件中没有任何空格，全都是连续的 0/1。Class 文件 中的所有内容被分为两种类型：无符号数、表。")]),v._v(" "),t("ul",[t("li",[v._v("无符号数：表示Class文件中的值，这些值没有任何类型，但是有不同的长度。u1、u2、u3、u4分别表示1/2/4/8个字节")]),v._v(" "),t("li",[v._v("表：由多个无符号数或者其他表作为数据项构成的复合数据类型")])]),v._v(" "),t("p",[v._v("Class文件具体由其他几个构成：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("魔数\nClass 文件的头 4 个字节称为魔数，用来表示这个 Class 文件的类型。\nClass 文件的魔数是用 16 进制表示的“CAFE BABE”")])]),v._v(" "),t("li",[t("p",[v._v("版本信息\n紧接着魔数的 4 个字节是版本信息，5-6 字节表示次版本号，7-8 字节表示主版本号，它们表示当前 Class 文件中使用的是哪个版本的 JDK。\n高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必需拒绝执行超过其版本号的 Class 文件。")])]),v._v(" "),t("li",[t("p",[v._v("常量池\n版本信息之后就是常量池，常量池中存放两种类型的常量：")]),v._v(" "),t("ul",[t("li",[v._v("字面值常量\n字面值常量就是我们在程序中定义的字符串、被 final 修饰的值。")]),v._v(" "),t("li",[v._v("符号引用\n符号引用就是我们定义的各种名字：类和接口的全限定名、字段的名字和描述符、方法的名字和描述符。")])])]),v._v(" "),t("li",[t("p",[v._v("访问标志\n在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否被 abstract/final 修饰")])]),v._v(" "),t("li",[t("p",[v._v("类索引、父类索引、接口索引集合\n类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。")])]),v._v(" "),t("li",[t("p",[v._v("字段表集合\n字段表集合存储本类涉及到的成员变量，包括实例变量和类变量，但不包括方法中的局部变量。\n每一个字段表只表示一个成员变量，本类中的所有成员变量构成了字段表集合")])]),v._v(" "),t("li",[t("p",[v._v("方法表集合")])])]),v._v(" "),t("p",[v._v("方法表结构与属性表类似。\nvolatile 关键字 和 transient关键字不能修饰方法，所以方法表的访问标志中没有ACC_VOLATILE和ACC_TRANSIENT 标志。\n方法表的属性表集合中有一张 Code 属性表，用于存储当前方法经编译器编译后的字节码指令。")]),v._v(" "),t("ul",[t("li",[v._v("属性表集合")])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("类型")]),v._v(" "),t("th",[v._v("名称")]),v._v(" "),t("th",[v._v("数量")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("u2")]),v._v(" "),t("td",[v._v("attribute_name_index")]),v._v(" "),t("td",[v._v("1")])]),v._v(" "),t("tr",[t("td",[v._v("u4")]),v._v(" "),t("td",[v._v("attribute_length")]),v._v(" "),t("td",[v._v("1")])]),v._v(" "),t("tr",[t("td",[v._v("u1")]),v._v(" "),t("td",[v._v("info")]),v._v(" "),t("td",[v._v("attribute_length")])])])])])}),[],!1,null,null,null);_.default=s.exports}}]);