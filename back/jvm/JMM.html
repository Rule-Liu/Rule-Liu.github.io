<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JVM内存结构 | RuleLau&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/icon.jpg">
    <meta name="description" content="我的个人网站">
    
    <link rel="preload" href="/assets/css/0.styles.99ba71c7.css" as="style"><link rel="preload" href="/assets/js/app.eb78e4ff.js" as="script"><link rel="preload" href="/assets/js/2.062734e7.js" as="script"><link rel="preload" href="/assets/js/26.ee5c4ae0.js" as="script"><link rel="prefetch" href="/assets/js/10.1fa9c2ce.js"><link rel="prefetch" href="/assets/js/11.b67db8c9.js"><link rel="prefetch" href="/assets/js/12.41340d35.js"><link rel="prefetch" href="/assets/js/13.f7873189.js"><link rel="prefetch" href="/assets/js/14.3a7cc814.js"><link rel="prefetch" href="/assets/js/15.7c3e8bd4.js"><link rel="prefetch" href="/assets/js/16.4d3c2513.js"><link rel="prefetch" href="/assets/js/17.0fce2c50.js"><link rel="prefetch" href="/assets/js/18.0fee2fc2.js"><link rel="prefetch" href="/assets/js/19.cd739ab0.js"><link rel="prefetch" href="/assets/js/20.ccee1235.js"><link rel="prefetch" href="/assets/js/21.3b3ad479.js"><link rel="prefetch" href="/assets/js/22.1a0c7439.js"><link rel="prefetch" href="/assets/js/23.e1875da8.js"><link rel="prefetch" href="/assets/js/24.5428519d.js"><link rel="prefetch" href="/assets/js/25.4be82a8e.js"><link rel="prefetch" href="/assets/js/27.6f1bb712.js"><link rel="prefetch" href="/assets/js/28.668b830a.js"><link rel="prefetch" href="/assets/js/29.e001ee62.js"><link rel="prefetch" href="/assets/js/3.7c25579e.js"><link rel="prefetch" href="/assets/js/30.14b54e61.js"><link rel="prefetch" href="/assets/js/31.8c7b7656.js"><link rel="prefetch" href="/assets/js/32.7895a749.js"><link rel="prefetch" href="/assets/js/33.7fdc13eb.js"><link rel="prefetch" href="/assets/js/34.497597fd.js"><link rel="prefetch" href="/assets/js/35.e45ce9de.js"><link rel="prefetch" href="/assets/js/36.dff9db21.js"><link rel="prefetch" href="/assets/js/37.84dca43f.js"><link rel="prefetch" href="/assets/js/38.d35b0106.js"><link rel="prefetch" href="/assets/js/39.cdb3310a.js"><link rel="prefetch" href="/assets/js/4.23425003.js"><link rel="prefetch" href="/assets/js/40.09ef43de.js"><link rel="prefetch" href="/assets/js/41.611a6d59.js"><link rel="prefetch" href="/assets/js/42.67cf3e85.js"><link rel="prefetch" href="/assets/js/43.6327f0de.js"><link rel="prefetch" href="/assets/js/5.cb6c276b.js"><link rel="prefetch" href="/assets/js/6.8acca1fd.js"><link rel="prefetch" href="/assets/js/7.fca05378.js"><link rel="prefetch" href="/assets/js/8.1f37df4a.js"><link rel="prefetch" href="/assets/js/9.f5dc1ff5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.99ba71c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/icon.jpg" alt="RuleLau's Blog" class="logo"> <span class="site-name can-hide">RuleLau's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/back/" class="nav-link router-link-active">
  后端
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/back/" class="nav-link router-link-active">
  后端
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JVM</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/back/jvm/JMM.html" aria-current="page" class="active sidebar-link">JVM内存结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/back/jvm/JVMStructure.html" class="sidebar-link">对象的内存布局</a></li><li><a href="/back/jvm/GCAlgorithm.html" class="sidebar-link">垃圾收集策略与算法</a></li><li><a href="/back/jvm/GC.html" class="sidebar-link">垃圾收集器</a></li><li><a href="/back/jvm/MemoryAllocation.html" class="sidebar-link">内存分配与回收策略</a></li><li><a href="/back/jvm/ClassStructure.html" class="sidebar-link">类文件结构</a></li><li><a href="/back/jvm/ClassLoader.html" class="sidebar-link">类加载</a></li><li><a href="/back/jvm/CMS、G1 垃圾收集器中的标记原理.html" class="sidebar-link">CMS、G1 垃圾收集器中的标记原理</a></li><li><a href="/back/jvm/jvm问题.html" class="sidebar-link">jvm 知识点</a></li><li><a href="/back/jvm/垃圾回收机制.html" class="sidebar-link">垃圾回收机制</a></li><li><a href="/back/jvm/垃圾收集器.html" class="sidebar-link">垃圾收集器过程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Concurrency</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ThreadPool</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringCloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Design Pattern</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Distributed-Transaction</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Utils</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="jvm内存结构"><a href="#jvm内存结构" class="header-anchor">#</a> JVM内存结构</h3> <h4 id="java虚拟机的内存空间分为5个部分"><a href="#java虚拟机的内存空间分为5个部分" class="header-anchor">#</a> Java虚拟机的内存空间分为5个部分：</h4> <ul><li>程序计数器</li> <li>Java虚拟机栈</li> <li>本地方法栈</li> <li>方法区</li> <li>堆</li></ul> <p><img src="https://i.loli.net/2021/01/24/jYg5kVTmaHIRdcp.png" alt="image.png"></p> <blockquote><p>JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。</p></blockquote> <h4 id="程序计数器-线程私有的"><a href="#程序计数器-线程私有的" class="header-anchor">#</a> 程序计数器（线程私有的）</h4> <h5 id="定义-程序计数器是一块较小的内存空间-是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法-那么此时程序计数器为undefined"><a href="#定义-程序计数器是一块较小的内存空间-是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法-那么此时程序计数器为undefined" class="header-anchor">#</a> 定义：程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为Undefined</h5> <h5 id="作用"><a href="#作用" class="header-anchor">#</a> 作用：</h5> <ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制</li> <li>当多线程时，因为程序计数器时每个线程都存在，所以当线程切换回来时，就可以知道上次线程执行到哪里了</li></ul> <h5 id="特点"><a href="#特点" class="header-anchor">#</a> 特点：</h5> <ul><li>是一块很小的内存区域，不会出现OutOfMemoryError的内存区域</li> <li>线程私有的，每条线程都有自己的程序计数器</li> <li>生命周期：随着线程的创建而创建，随着线程的结束而销毁</li></ul> <h5 id="java虚拟机栈"><a href="#java虚拟机栈" class="header-anchor">#</a> Java虚拟机栈</h5> <h5 id="定义-java-虚拟机栈是描述-java-方法运行过程的内存模型。java-虚拟机栈会为每一个即将运行的-java-方法创建一块叫做-栈帧-的区域-用于存放该方法运行过程中的一些信息-如"><a href="#定义-java-虚拟机栈是描述-java-方法运行过程的内存模型。java-虚拟机栈会为每一个即将运行的-java-方法创建一块叫做-栈帧-的区域-用于存放该方法运行过程中的一些信息-如" class="header-anchor">#</a> 定义：Java 虚拟机栈是描述 Java 方法运行过程的内存模型。Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：</h5> <ul><li>局部变量表</li> <li>操作数栈</li> <li>动态链接</li> <li>方法出口信息</li></ul> <p><img src="https://i.loli.net/2021/01/24/o6HAOd2kntLDBl5.png" alt="image.png"></p> <h5 id="特点-2"><a href="#特点-2" class="header-anchor">#</a> 特点：</h5> <ul><li><p>局部变量表随着栈帧的创建而创建，大小在编译时确定，创建时只需要事先分配先规定的大小即可。在方法运行时，局部变量表的大小不会改变。</p></li> <li><p>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError</p> <ul><li>StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</li> <li>OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</li></ul></li> <li><p>Java虚拟机栈也是线程私有的，随着线程创建而创建，随着线程的结束而销毁</p></li> <li><p>出现StackOverFlowError 时，内存空间可能还有很多</p></li></ul> <h4 id="本地方法栈"><a href="#本地方法栈" class="header-anchor">#</a> 本地方法栈</h4> <h5 id="定义-本地方法栈是为jvm运行的native方法准备的空间-由于很多native方法都是用c语言实现的-所以它通常又叫-c-栈。它与-java-虚拟机栈实现的功能类似-只不过本地方法栈是描述本地方法运行过程的内存模型"><a href="#定义-本地方法栈是为jvm运行的native方法准备的空间-由于很多native方法都是用c语言实现的-所以它通常又叫-c-栈。它与-java-虚拟机栈实现的功能类似-只不过本地方法栈是描述本地方法运行过程的内存模型" class="header-anchor">#</a> 定义：本地方法栈是为JVM运行的Native方法准备的空间，由于很多Native方法都是用C语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型</h5> <h4 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h4> <h5 id="定义-堆是用来存放对象的内存空间-几乎所有的对象都存储在堆中"><a href="#定义-堆是用来存放对象的内存空间-几乎所有的对象都存储在堆中" class="header-anchor">#</a> 定义：堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中</h5> <h5 id="特点-3"><a href="#特点-3" class="header-anchor">#</a> 特点：</h5> <ul><li>线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个</li> <li>在虚拟机启动时创建</li> <li>垃圾回收的主要场所</li> <li>分为新生代（Eden区，From Survior, To Survivor）、老年代</li> <li>堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。</li></ul> <h5 id="方法区"><a href="#方法区" class="header-anchor">#</a> 方法区</h5> <h5 id="定义-java-虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息"><a href="#定义-java-虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息" class="header-anchor">#</a> 定义：Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：</h5> <ul><li>已经被虚拟机加载的类信息</li> <li>常量</li> <li>静态变量</li> <li>即时编译器编译后的代码</li></ul> <h5 id="特点-4"><a href="#特点-4" class="header-anchor">#</a> 特点:</h5> <ul><li>线程共享，方法区是堆的逻辑分区，是线程共享的，整个虚拟机只有一个方法区</li> <li>称为永久代</li> <li>内存回收率低，因为处于永久代的信息大都需要长期存在，主要的回收目标是：对常量池的回收、类型的卸载</li> <li>允许固定大小或者动态扩展</li></ul> <h5 id="运行时常量池"><a href="#运行时常量池" class="header-anchor">#</a> 运行时常量池</h5> <ul><li>方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中</li> <li>当类被Java虚拟机加载后，.class文件中的常量就存放在方法区的运行时常量池中</li></ul> <h4 id="直接内存-堆外内存"><a href="#直接内存-堆外内存" class="header-anchor">#</a> 直接内存（堆外内存）</h4> <p>直接内存是除Java虚拟机以外的内存，但也可能被Java使用</p> <h5 id="操作直接内存"><a href="#操作直接内存" class="header-anchor">#</a> 操作直接内存</h5> <ul><li>在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。</li> <li>直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</li></ul> <h5 id="直接内存与堆内存比较"><a href="#直接内存与堆内存比较" class="header-anchor">#</a> 直接内存与堆内存比较</h5> <ul><li>直接内存申请空间耗费更高的性能</li> <li>直接内存读取 IO 的性能要优于普通的堆内存。</li> <li>直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO堆内存作用链：</li> <li>本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2021/1/29 上午7:42:17</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/back/jvm/JVMStructure.html">
        对象的内存布局
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.eb78e4ff.js" defer></script><script src="/assets/js/2.062734e7.js" defer></script><script src="/assets/js/26.ee5c4ae0.js" defer></script>
  </body>
</html>
