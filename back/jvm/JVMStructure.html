<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>对象的内存布局 | RuleLau&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/icon.jpg">
    <meta name="description" content="我的个人网站">
    
    <link rel="preload" href="/assets/css/0.styles.99ba71c7.css" as="style"><link rel="preload" href="/assets/js/app.eb78e4ff.js" as="script"><link rel="preload" href="/assets/js/2.062734e7.js" as="script"><link rel="preload" href="/assets/js/27.6f1bb712.js" as="script"><link rel="prefetch" href="/assets/js/10.1fa9c2ce.js"><link rel="prefetch" href="/assets/js/11.b67db8c9.js"><link rel="prefetch" href="/assets/js/12.41340d35.js"><link rel="prefetch" href="/assets/js/13.f7873189.js"><link rel="prefetch" href="/assets/js/14.3a7cc814.js"><link rel="prefetch" href="/assets/js/15.7c3e8bd4.js"><link rel="prefetch" href="/assets/js/16.4d3c2513.js"><link rel="prefetch" href="/assets/js/17.0fce2c50.js"><link rel="prefetch" href="/assets/js/18.0fee2fc2.js"><link rel="prefetch" href="/assets/js/19.cd739ab0.js"><link rel="prefetch" href="/assets/js/20.ccee1235.js"><link rel="prefetch" href="/assets/js/21.3b3ad479.js"><link rel="prefetch" href="/assets/js/22.1a0c7439.js"><link rel="prefetch" href="/assets/js/23.e1875da8.js"><link rel="prefetch" href="/assets/js/24.5428519d.js"><link rel="prefetch" href="/assets/js/25.4be82a8e.js"><link rel="prefetch" href="/assets/js/26.ee5c4ae0.js"><link rel="prefetch" href="/assets/js/28.668b830a.js"><link rel="prefetch" href="/assets/js/29.e001ee62.js"><link rel="prefetch" href="/assets/js/3.7c25579e.js"><link rel="prefetch" href="/assets/js/30.14b54e61.js"><link rel="prefetch" href="/assets/js/31.8c7b7656.js"><link rel="prefetch" href="/assets/js/32.7895a749.js"><link rel="prefetch" href="/assets/js/33.7fdc13eb.js"><link rel="prefetch" href="/assets/js/34.497597fd.js"><link rel="prefetch" href="/assets/js/35.e45ce9de.js"><link rel="prefetch" href="/assets/js/36.dff9db21.js"><link rel="prefetch" href="/assets/js/37.84dca43f.js"><link rel="prefetch" href="/assets/js/38.d35b0106.js"><link rel="prefetch" href="/assets/js/39.cdb3310a.js"><link rel="prefetch" href="/assets/js/4.23425003.js"><link rel="prefetch" href="/assets/js/40.09ef43de.js"><link rel="prefetch" href="/assets/js/41.611a6d59.js"><link rel="prefetch" href="/assets/js/42.67cf3e85.js"><link rel="prefetch" href="/assets/js/43.6327f0de.js"><link rel="prefetch" href="/assets/js/5.cb6c276b.js"><link rel="prefetch" href="/assets/js/6.8acca1fd.js"><link rel="prefetch" href="/assets/js/7.fca05378.js"><link rel="prefetch" href="/assets/js/8.1f37df4a.js"><link rel="prefetch" href="/assets/js/9.f5dc1ff5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.99ba71c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/icon.jpg" alt="RuleLau's Blog" class="logo"> <span class="site-name can-hide">RuleLau's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/back/" class="nav-link router-link-active">
  后端
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/back/" class="nav-link router-link-active">
  后端
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JVM</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/back/jvm/JMM.html" class="sidebar-link">JVM内存结构</a></li><li><a href="/back/jvm/JVMStructure.html" aria-current="page" class="active sidebar-link">对象的内存布局</a></li><li><a href="/back/jvm/GCAlgorithm.html" class="sidebar-link">垃圾收集策略与算法</a></li><li><a href="/back/jvm/GC.html" class="sidebar-link">垃圾收集器</a></li><li><a href="/back/jvm/MemoryAllocation.html" class="sidebar-link">内存分配与回收策略</a></li><li><a href="/back/jvm/ClassStructure.html" class="sidebar-link">类文件结构</a></li><li><a href="/back/jvm/ClassLoader.html" class="sidebar-link">类加载</a></li><li><a href="/back/jvm/CMS、G1 垃圾收集器中的标记原理.html" class="sidebar-link">CMS、G1 垃圾收集器中的标记原理</a></li><li><a href="/back/jvm/jvm问题.html" class="sidebar-link">jvm 知识点</a></li><li><a href="/back/jvm/垃圾回收机制.html" class="sidebar-link">垃圾回收机制</a></li><li><a href="/back/jvm/垃圾收集器.html" class="sidebar-link">垃圾收集器过程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Concurrency</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ThreadPool</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringCloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Design Pattern</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Distributed-Transaction</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Utils</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h4 id="对象的内存布局"><a href="#对象的内存布局" class="header-anchor">#</a> 对象的内存布局</h4> <p>在HotSpot虚拟机中，对象的内存布局分为以下3块区域：</p> <ul><li>对象头
<ul><li>markword 4字节</li> <li>class对象指针 4字节</li></ul></li> <li>实例数据</li> <li>对齐填充 8个字节的整数倍</li></ul> <p><img src="https://i.loli.net/2021/01/24/3VQjNsI1tAmT9Zo.png" alt="image.png"></p> <h5 id="对象头"><a href="#对象头" class="header-anchor">#</a> 对象头</h5> <p>对象头记录了对象在运行过程中所需要使用的一些数据：</p> <ul><li>哈希码</li> <li>GC分代年龄</li> <li>锁状态标志</li> <li>线程持有的锁</li> <li>偏向线程ID</li> <li>偏向时间戳</li></ul> <blockquote><p>对象头可能包含类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包括数组长度。</p></blockquote> <h5 id="实例数据"><a href="#实例数据" class="header-anchor">#</a> 实例数据</h5> <p>实例数据部分就是成员变量的值，其中包括父类成员变量和本类成员变量。</p> <h5 id="对齐填充"><a href="#对齐填充" class="header-anchor">#</a> 对齐填充</h5> <p>用于确保对象的总长度为 8 字节的整数倍。
HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p> <blockquote><p>对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。</p></blockquote> <h4 id="对象的创建过程"><a href="#对象的创建过程" class="header-anchor">#</a> 对象的创建过程</h4> <h5 id="类加载检查"><a href="#类加载检查" class="header-anchor">#</a> 类加载检查</h5> <p>虚拟机在解析.class文件时，如果遇到一条new 指令，首先它会去检查常量池中是否有这个类的符号引用，并且检查这个符号引用代表的泪是否已经加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。</p> <h5 id="为新生对象分配内存"><a href="#为新生对象分配内存" class="header-anchor">#</a> 为新生对象分配内存</h5> <p>对象所需内存的大小在类加载完成后便可完全确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中的内存有两种方式：</p> <ul><li><p>指针碰撞
如果 Java 堆中内存绝对规整（说明采用的是“复制算法”或“标记整理法”），空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“指针碰撞”。</p></li> <li><p>空闲列表
如果 Java 堆中内存并不规整，已使用的内存和空闲内存交错（说明采用的是标记-清除法，有碎片），此时没法简单进行指针碰撞， VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。这种方式称为“空闲列表”。</p></li></ul> <h5 id="初始化"><a href="#初始化" class="header-anchor">#</a> 初始化</h5> <p>分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。至此，整个对象的创建过程就完成了。</p> <h5 id="对象的访问方式"><a href="#对象的访问方式" class="header-anchor">#</a> 对象的访问方式</h5> <p>所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。 那么根据引用存放的地址类型的不同，对象有不同的访问方式。</p> <ul><li><p>句柄访问方式
堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。
<img src="https://i.loli.net/2021/01/24/178XeFRGdqfHZ3P.png" alt="image.png"></p></li> <li><p>直接指针访问方式（重点）
引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。
<img src="https://i.loli.net/2021/01/24/qANTSx6Rnsihz1Q.png" alt="image.png"></p></li></ul> <blockquote><p>需要说明的是，HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要额外的策略来存储对象在方法区中类信息的地址。</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2021/1/29 上午7:42:17</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/back/jvm/JMM.html" class="prev">
        JVM内存结构
      </a></span> <span class="next"><a href="/back/jvm/GCAlgorithm.html">
        垃圾收集策略与算法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.eb78e4ff.js" defer></script><script src="/assets/js/2.062734e7.js" defer></script><script src="/assets/js/27.6f1bb712.js" defer></script>
  </body>
</html>
