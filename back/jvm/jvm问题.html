<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>jvm 知识点 | RuleLau&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/icon.jpg">
    <meta name="description" content="我的个人网站">
    
    <link rel="preload" href="/assets/css/0.styles.99ba71c7.css" as="style"><link rel="preload" href="/assets/js/app.eb78e4ff.js" as="script"><link rel="preload" href="/assets/js/2.062734e7.js" as="script"><link rel="preload" href="/assets/js/29.e001ee62.js" as="script"><link rel="prefetch" href="/assets/js/10.1fa9c2ce.js"><link rel="prefetch" href="/assets/js/11.b67db8c9.js"><link rel="prefetch" href="/assets/js/12.41340d35.js"><link rel="prefetch" href="/assets/js/13.f7873189.js"><link rel="prefetch" href="/assets/js/14.3a7cc814.js"><link rel="prefetch" href="/assets/js/15.7c3e8bd4.js"><link rel="prefetch" href="/assets/js/16.4d3c2513.js"><link rel="prefetch" href="/assets/js/17.0fce2c50.js"><link rel="prefetch" href="/assets/js/18.0fee2fc2.js"><link rel="prefetch" href="/assets/js/19.cd739ab0.js"><link rel="prefetch" href="/assets/js/20.ccee1235.js"><link rel="prefetch" href="/assets/js/21.3b3ad479.js"><link rel="prefetch" href="/assets/js/22.1a0c7439.js"><link rel="prefetch" href="/assets/js/23.e1875da8.js"><link rel="prefetch" href="/assets/js/24.5428519d.js"><link rel="prefetch" href="/assets/js/25.4be82a8e.js"><link rel="prefetch" href="/assets/js/26.ee5c4ae0.js"><link rel="prefetch" href="/assets/js/27.6f1bb712.js"><link rel="prefetch" href="/assets/js/28.668b830a.js"><link rel="prefetch" href="/assets/js/3.7c25579e.js"><link rel="prefetch" href="/assets/js/30.14b54e61.js"><link rel="prefetch" href="/assets/js/31.8c7b7656.js"><link rel="prefetch" href="/assets/js/32.7895a749.js"><link rel="prefetch" href="/assets/js/33.7fdc13eb.js"><link rel="prefetch" href="/assets/js/34.497597fd.js"><link rel="prefetch" href="/assets/js/35.e45ce9de.js"><link rel="prefetch" href="/assets/js/36.dff9db21.js"><link rel="prefetch" href="/assets/js/37.84dca43f.js"><link rel="prefetch" href="/assets/js/38.d35b0106.js"><link rel="prefetch" href="/assets/js/39.cdb3310a.js"><link rel="prefetch" href="/assets/js/4.23425003.js"><link rel="prefetch" href="/assets/js/40.09ef43de.js"><link rel="prefetch" href="/assets/js/41.611a6d59.js"><link rel="prefetch" href="/assets/js/42.67cf3e85.js"><link rel="prefetch" href="/assets/js/43.6327f0de.js"><link rel="prefetch" href="/assets/js/5.cb6c276b.js"><link rel="prefetch" href="/assets/js/6.8acca1fd.js"><link rel="prefetch" href="/assets/js/7.fca05378.js"><link rel="prefetch" href="/assets/js/8.1f37df4a.js"><link rel="prefetch" href="/assets/js/9.f5dc1ff5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.99ba71c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/icon.jpg" alt="RuleLau's Blog" class="logo"> <span class="site-name can-hide">RuleLau's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/back/" class="nav-link router-link-active">
  后端
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/back/" class="nav-link router-link-active">
  后端
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JVM</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/back/jvm/JMM.html" class="sidebar-link">JVM内存结构</a></li><li><a href="/back/jvm/JVMStructure.html" class="sidebar-link">对象的内存布局</a></li><li><a href="/back/jvm/GCAlgorithm.html" class="sidebar-link">垃圾收集策略与算法</a></li><li><a href="/back/jvm/GC.html" class="sidebar-link">垃圾收集器</a></li><li><a href="/back/jvm/MemoryAllocation.html" class="sidebar-link">内存分配与回收策略</a></li><li><a href="/back/jvm/ClassStructure.html" class="sidebar-link">类文件结构</a></li><li><a href="/back/jvm/ClassLoader.html" class="sidebar-link">类加载</a></li><li><a href="/back/jvm/CMS、G1 垃圾收集器中的标记原理.html" class="sidebar-link">CMS、G1 垃圾收集器中的标记原理</a></li><li><a href="/back/jvm/jvm问题.html" class="active sidebar-link">jvm 知识点</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/back/jvm/垃圾回收机制.html" class="sidebar-link">垃圾回收机制</a></li><li><a href="/back/jvm/垃圾收集器.html" class="sidebar-link">垃圾收集器过程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Concurrency</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ThreadPool</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringCloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Design Pattern</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Distributed-Transaction</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Utils</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="jvm-知识点"><a href="#jvm-知识点" class="header-anchor">#</a> jvm 知识点</h3> <ol><li><p>程序计数器和栈帧为什么不能放在一起？</p></li> <li><p>tomcat 破坏双亲委派模型的原因？</p></li> <li><p>方法区、永久代、元空间的关系？</p></li> <li><p>双亲委派模型的设计？</p></li> <li><p>方法区回收的条件？</p> <ol><li>该类的所有实例（堆中）都已经被回收。</li> <li>该类的classloader已经被回收。</li> <li>该类的对应的class 对象没有任何引用。</li></ol></li> <li><p>类初始化的时机？</p> <ol><li>当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）</li> <li>当调用某个类的静态方法时</li> <li>当使用某个类或接口的静态字段时</li> <li>调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时</li> <li>当初始化某个子类时</li> <li>当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类） 所以System.ou.println(Test.class)不满足上面6种情 况，也就没有做初始化</li></ol></li> <li><p>Java 对象中的引用类型？</p> <ol><li>强引用：一个变量引用一个对象。例如 Object obj = new Object(); 垃圾回收不会去回收这个对象。</li> <li>软引用：实例对象用一个SofrRefrence 软引用类型的包装的对象，例如 <code>SoftReference&lt;Object&gt; softReference = new SoftReference&lt;&gt;(new Object());</code> 正常情况垃圾回收不会回收它，但是发现内存空间不够存放新的对象时，内存快溢出时，就会进行回收。</li> <li>弱引用：无论内存是否足够，只要垃圾回收开始，那么就会将弱引用关联对象就会被回收。例如 <code>WeakReference&lt;Object&gt; weakReference = new WeakReference&lt;&gt;(new Object());</code></li> <li>虚引用：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。例如：<code>PhantomReference&lt;Object&gt; phantomReference = new PhantomReference&lt;&gt;(new Object(), new ReferenceQueue&lt;&gt;());</code>当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</li></ol></li> <li><p>parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？答：根据年轻代对象放入老年代的规则可知
我觉的应该考虑两个方向：避免FullGC和避免年轻代对象进入老年代</p> <ul><li>避免FullGC
1、保证老年代可用空间大于新生代所有对象，避免MinorGC前进行FullGC
2、如果1可以保证，那后面-XX：HandlePromotionFailure、进入老年代的对象平均大小等比较就不需要考虑了
3、保证MinorGC后存活对象不大于Survivor空间</li> <li>避免年轻代对象进入老年代
1、根据实际情况查看每次MinorGC后存活对象的大小，设置合适的Survivor区域大小，保证存活对象进入survivor区，而不是进入老年代
2、根据对象存活的时间以及MinorGC的间隔时间，确定年龄。比如：3分钟一次MinorGC，而对象可以存活1个小时，那就把对象年龄设置到20,避免对象15岁进入老年代
3、大对象如果偶尔创建一个，可以设置-XX:PretenureSizeThreshold，使其分配至年轻代。如果创建销毁频繁，就让其直接进入老年代，利用对象池避免频繁创建销毁</li></ul> <ol><li>设置晋升老年代年龄的阈值从15加到30.</li> <li>判断Eden区满时，进行Minor GC 后剩余的对象是否能够被Survivor 区放下，如果能够放下，则可以减少进入老年代的次数。</li> <li>将年轻代与老年代的比例设置为2：1，然后将Eden区和Survivor区比例进行修改，从8:1:1到6:2:2。 这样可以增加Minor GC，减少Full GC.</li></ol></li> <li><p>CMS 默认启动的垃圾回收线程数量：（CPU核数+3）/ 4</p></li> <li><p>Concurrent Mode Failure 问题: CMS 并发清理清理阶段，CMS 只不过回收之前标记好的垃圾对象，应用线程会一直进行，可能会进行Minor GC, 那么从年轻代晋升的新的对象，有可能直接放入老年代，这时候，老年代也放不下，就会导致  Concurrent Mode Failure 问题。这时，老年代中可能也会存在没人引用的对象，那么这个就是“浮动垃圾”。然后CMS会自动降级，使用&quot;Serial Old&quot;垃圾回收器，强行系统STW，重新进行标记，清理。</p></li> <li><p>CMS 触发时机：当老年代内存占用一定比例，就会自动执行GC,“-XX:CMSInitiatingOccupancyFaction”参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是 92%。</p></li> <li><p>CMS 内存碎片化问题，CMS 老年代是标记-清理，CMS有一个参数是“-XX:+UseCMSCompactAtFullCollection”，默认就打开了 他意思是在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。还有一个参数是“-XX:CMSFullGCsBeforeCompaction”，这个意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认 是0，意思就是每次Full GC之后都会进行一次内存整理。</p></li> <li><p>触发 老年代GC 的条件是什么？</p> <ol><li>老年代已用空间达到了参数 CMSInitiatingOccupancyFaction 设置的比例时会自动触发，默认为92%</li></ol></li> <li><p>OOM 触发的机制：full gc同时一般会伴随着一次minor GC，如果第一次full GC过程中，因为新创建的对象原因又达到了触发fullGC的条件，首先还是会先minorGC，然后尝试放入新生代,但此时老年代还没有回收完成，再触发一次MajorGC没什么意义，因为重新标记会干了这个事情。 如果minorGC后，新创建的对象仍然放不进内存，需要等待MajorGC结束，如果MajorGC结束后仍然放不进去，就会OOM了</p></li></ol> <h4 id="垃圾收集器"><a href="#垃圾收集器" class="header-anchor">#</a> 垃圾收集器</h4> <ol><li>G1 收集器的作用？
<ol><li>可以设置系统预计停顿时间，来选择最少回收时间和最多回收对象的 Region 进行垃圾回收。保证GC 对系统停顿影响在可控范围内，同时还可以尽可能回收最多的对象。</li></ol></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/back/jvm/CMS、G1 垃圾收集器中的标记原理.html" class="prev">
        CMS、G1 垃圾收集器中的标记原理
      </a></span> <span class="next"><a href="/back/jvm/垃圾回收机制.html">
        垃圾回收机制
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.eb78e4ff.js" defer></script><script src="/assets/js/2.062734e7.js" defer></script><script src="/assets/js/29.e001ee62.js" defer></script>
  </body>
</html>
