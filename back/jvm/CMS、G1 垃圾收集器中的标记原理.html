<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>CMS、G1 垃圾收集器中的标记原理 | RuleLau&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/icon.jpg">
    <meta name="description" content="我的个人网站">
    
    <link rel="preload" href="/assets/css/0.styles.99ba71c7.css" as="style"><link rel="preload" href="/assets/js/app.eb78e4ff.js" as="script"><link rel="preload" href="/assets/js/2.062734e7.js" as="script"><link rel="preload" href="/assets/js/21.3b3ad479.js" as="script"><link rel="prefetch" href="/assets/js/10.1fa9c2ce.js"><link rel="prefetch" href="/assets/js/11.b67db8c9.js"><link rel="prefetch" href="/assets/js/12.41340d35.js"><link rel="prefetch" href="/assets/js/13.f7873189.js"><link rel="prefetch" href="/assets/js/14.3a7cc814.js"><link rel="prefetch" href="/assets/js/15.7c3e8bd4.js"><link rel="prefetch" href="/assets/js/16.4d3c2513.js"><link rel="prefetch" href="/assets/js/17.0fce2c50.js"><link rel="prefetch" href="/assets/js/18.0fee2fc2.js"><link rel="prefetch" href="/assets/js/19.cd739ab0.js"><link rel="prefetch" href="/assets/js/20.ccee1235.js"><link rel="prefetch" href="/assets/js/22.1a0c7439.js"><link rel="prefetch" href="/assets/js/23.e1875da8.js"><link rel="prefetch" href="/assets/js/24.5428519d.js"><link rel="prefetch" href="/assets/js/25.4be82a8e.js"><link rel="prefetch" href="/assets/js/26.ee5c4ae0.js"><link rel="prefetch" href="/assets/js/27.6f1bb712.js"><link rel="prefetch" href="/assets/js/28.668b830a.js"><link rel="prefetch" href="/assets/js/29.e001ee62.js"><link rel="prefetch" href="/assets/js/3.7c25579e.js"><link rel="prefetch" href="/assets/js/30.14b54e61.js"><link rel="prefetch" href="/assets/js/31.8c7b7656.js"><link rel="prefetch" href="/assets/js/32.7895a749.js"><link rel="prefetch" href="/assets/js/33.7fdc13eb.js"><link rel="prefetch" href="/assets/js/34.497597fd.js"><link rel="prefetch" href="/assets/js/35.e45ce9de.js"><link rel="prefetch" href="/assets/js/36.dff9db21.js"><link rel="prefetch" href="/assets/js/37.84dca43f.js"><link rel="prefetch" href="/assets/js/38.d35b0106.js"><link rel="prefetch" href="/assets/js/39.cdb3310a.js"><link rel="prefetch" href="/assets/js/4.23425003.js"><link rel="prefetch" href="/assets/js/40.09ef43de.js"><link rel="prefetch" href="/assets/js/41.611a6d59.js"><link rel="prefetch" href="/assets/js/42.67cf3e85.js"><link rel="prefetch" href="/assets/js/43.6327f0de.js"><link rel="prefetch" href="/assets/js/5.cb6c276b.js"><link rel="prefetch" href="/assets/js/6.8acca1fd.js"><link rel="prefetch" href="/assets/js/7.fca05378.js"><link rel="prefetch" href="/assets/js/8.1f37df4a.js"><link rel="prefetch" href="/assets/js/9.f5dc1ff5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.99ba71c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/icon.jpg" alt="RuleLau's Blog" class="logo"> <span class="site-name can-hide">RuleLau's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/back/" class="nav-link router-link-active">
  后端
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/back/" class="nav-link router-link-active">
  后端
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JVM</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/back/jvm/JMM.html" class="sidebar-link">JVM内存结构</a></li><li><a href="/back/jvm/JVMStructure.html" class="sidebar-link">对象的内存布局</a></li><li><a href="/back/jvm/GCAlgorithm.html" class="sidebar-link">垃圾收集策略与算法</a></li><li><a href="/back/jvm/GC.html" class="sidebar-link">垃圾收集器</a></li><li><a href="/back/jvm/MemoryAllocation.html" class="sidebar-link">内存分配与回收策略</a></li><li><a href="/back/jvm/ClassStructure.html" class="sidebar-link">类文件结构</a></li><li><a href="/back/jvm/ClassLoader.html" class="sidebar-link">类加载</a></li><li><a href="/back/jvm/CMS、G1 垃圾收集器中的标记原理.html" class="active sidebar-link">CMS、G1 垃圾收集器中的标记原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/back/jvm/jvm问题.html" class="sidebar-link">jvm 知识点</a></li><li><a href="/back/jvm/垃圾回收机制.html" class="sidebar-link">垃圾回收机制</a></li><li><a href="/back/jvm/垃圾收集器.html" class="sidebar-link">垃圾收集器过程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Concurrency</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ThreadPool</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>SpringCloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Design Pattern</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Distributed-Transaction</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Docker</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Utils</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="cms、g1-垃圾收集器中的标记原理"><a href="#cms、g1-垃圾收集器中的标记原理" class="header-anchor">#</a> CMS、G1 垃圾收集器中的标记原理</h3> <h3 id="跨代引用"><a href="#跨代引用" class="header-anchor">#</a> 跨代引用</h3> <p>所谓跨代引用就是老年代的对象引用了新生代的对象，或者新生代的对象引用了老年代的对象。那对于这种情况我们的GC在进行扫描的时候不可能直接把我们的整个堆都扫描完，那这样效率也太低了。所以这时候就需要开辟了一小块空间，维护这种引用，而不必让GC扫描整个堆区域。</p> <h3 id="gc-root-定义"><a href="#gc-root-定义" class="header-anchor">#</a> GC Root 定义</h3> <p>GC root 所关联的对象是分为两个大的对象：</p> <ol><li>全局对象
<ul><li>方法区静态属性引用的对象：Class对象本身很难被回收，回收的条件非常苛刻，只要Class对象不被回收，静态成员就不能被回收。</li> <li>方法区常量池引用的对象：例如字符串常量池，常量本身初始化后不会再改变，因此作为GC Roots也是合理的。</li></ul></li> <li>执行上下文
<ul><li>虚拟机栈中栈帧的局部变量表引用的对象：线程在执行方法时，会将方法打包成一个栈帧入栈执行，方法里用到的局部变量会存放到栈帧的本地变量表中。只要方法还在运行，还没出栈，就意味这本地变量表的对象还会被访问，GC就不应该回收。</li> <li>本地方法栈中JNI (Native 方法) 引用的对象：Java方法栈中的变量引用，一个是native方法(C、C++)方法栈中的变量引用。</li> <li>被同步锁持有的对象：被synchronized锁住的对象也是绝对不能回收。</li></ul></li></ol> <h3 id="gc-roots-的范围"><a href="#gc-roots-的范围" class="header-anchor">#</a> GC Roots 的范围</h3> <p>CMS 和 G1 垃圾收集器的回收过程中都存在初始标记，都是其扫描GC Root， 虚拟机为了避免全堆扫描和跨代引用的问题，引入了 Remember Set（记忆集），存储了年轻代中的对象，而 CardTable 卡表，则是 HotSpot 对于记忆集的实现，CardTable是一个字节数组(jbyte*)，数组中的每个元素称为一个card。一个内存地址可以被映射到CardTable中的一个位置上。</p> <blockquote><p>对于G1来说，每个Region都有一个CardTable，每个CardTable都有若干大小为512字节的card用于存储其它Region的对象地址。当Region A的一个对象A在引用Region B的一个对象B的时候，会通过写屏障将A对象的地址映射到Region B的CardTable中，标识对应card为dirty，之后在对Region B进行根节点枚举的时候，会把Region B的CardTable中被标记为dirty的card纳入到根节点的范围中进行扫描，以此避免去扫描Region A。
如果对应到分代的情况，那就是在新生代中记录了老年代的一块块地址，在Minor GC的时候，直接从CardTable中获取到需要扫描的老年代对象，而不用去扫描整个老年代。</p></blockquote> <h3 id="_2-三色标记"><a href="#_2-三色标记" class="header-anchor">#</a> 2. 三色标记</h3> <p>存在于标记的过程，使用的该算法，分为三种颜色，分别对应着标记对象的状态：</p> <ul><li>黑色：从GC Roots 开始，已经扫描过它全部引用的对象，标记为黑色。（不能被回收）</li> <li>灰色：扫描过对象本身，还没完全扫描过它全部引用的对象，标记为灰色。</li> <li>白色：还没扫描过的对象，标记为白色。</li></ul> <p>标记流程如下：</p> <ol><li>刚开始，所有的对象都是白色，没有被访问。</li> <li>将GC Roots直接关联的对象置为灰色。</li> <li>遍历灰色对象的所有引用，遍历后灰色对象本身置为黑色，引用置为灰色。</li> <li>重复步骤3，直到没有灰色对象为止。结束时，黑色对象存活，白色对象回收。</li></ol> <h3 id="_3-为什么gc-要-stw"><a href="#_3-为什么gc-要-stw" class="header-anchor">#</a> 3. 为什么GC 要 STW?</h3> <p>首先，如果不暂停用户线程，就意味着期间会不断有垃圾产生，永远也清理不干净。其次，用户线程的运行必然会导致对象的引用关系发生改变，这就会导致两种情况：<strong>漏标</strong> 和 <strong>错标</strong>。</p> <h4 id="漏标"><a href="#漏标" class="header-anchor">#</a> 漏标</h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token number">1.</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token class-name">B</span> <span class="token operator">=</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
<span class="token number">2.</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token class-name">C</span> <span class="token operator">=</span> <span class="token class-name">C</span><span class="token punctuation">;</span>
<span class="token number">3.</span> <span class="token class-name">B</span><span class="token punctuation">.</span><span class="token class-name">C</span> <span class="token operator">=</span> <span class="token keyword">null</span>；
<span class="token number">4.</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token class-name">C</span> <span class="token operator">=</span> <span class="token class-name">C</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>根据上述代码，仅仅在第1、2步时，状态：黑色-&gt;灰色-&gt;白色， 如下图</li></ol> <p><img src="https://gitee.com/rule-liu/pic/raw/master/img/20211018141028.png" alt=""></p> <ol start="2"><li>如果一切顺利，不发生任何引用变化，GC线程顺着灰色的引用向下扫描,最后都变成黑色，都是存活对象。</li> <li>但是如果出现了这样一个状况，在扫描到灰色的时候，还没有扫描到这个白色对象，此时，黑色对象引用了这个白色对象，而灰色对象指向了别的对象，或者干脆指向了null，也就是取消了对白色对象的引用。（代码中的3，4步），如下图</li></ol> <p><img src="https://gitee.com/rule-liu/pic/raw/master/img/20211018140817.png" alt=""></p> <ol start="4"><li>根据三色标记的规则，GC 会认为黑色对象是已经扫描过的了，不会再对A指向的对象进行扫描，也就不会扫描到C白色对象，最后结果就是,白色对象直到本次标记扫描结束,也是白色,根据三色标记规则,认为它是垃圾,被清理掉。
<img src="https://gitee.com/rule-liu/pic/raw/master/img/20211018141136.png" alt=""></li></ol> <h3 id="_4-解决三色标记的问题"><a href="#_4-解决三色标记的问题" class="header-anchor">#</a> 4. 解决三色标记的问题</h3> <p>上面的漏标问题，就会导致对象被错误的回收了，漏标的两个必要条件：</p> <ul><li>有至少一个黑色对象在自己被标记之后指向这个白色对象。</li> <li>所有的灰色对象在自己引用扫描完成之前删除了对白色对象的引用。</li></ul> <h4 id="cms-增量更新"><a href="#cms-增量更新" class="header-anchor">#</a> CMS 增量更新</h4> <p>增量更新破坏的是第一个条件,我们在这个黑色对象增加了对白色对象的引用之后,将它的这个引用,记录下来,在最后标记的时候,再以这个黑色对象为根,对它的引用进行重新扫描。
可以简单理解为,当一个黑色对象增加了对白色对象的引用,那么这个黑色对象就被变灰。
这样有一个缺点,就是会重新扫描这个黑色对象的所有引用,比较浪费时间。</p> <h4 id="g1-原始快照-satb"><a href="#g1-原始快照-satb" class="header-anchor">#</a> G1 原始快照 （SATB）</h4> <p>原始快照破坏的是第二个条件,我们在这个灰色对象取消对白色对象的引用之前,将这个引用记录下来,在最后标记的时候,再以这个引用指向的白色对象为根,对它的引用进行扫描。可以简单理解为,当一个灰色对象取消了对白色对象的引用,那么这个白色对象被变灰。</p> <p>这样做的缺点就是,这个白色对象有可能并没有黑色对象去引用它,但是它还是被变灰了,就会导致它和它的引用,本来应该被垃圾回收掉,但是此次GC存活了下来,就是所谓的浮动垃圾.其实这样是比较可以忍受的,只是让它多存活了一次GC而已,浪费一点点空间,但是会比增量更新更省时间。</p> <h3 id="为什么g1用satb-cms用增量更新"><a href="#为什么g1用satb-cms用增量更新" class="header-anchor">#</a> 为什么G1用SATB？CMS用增量更新？</h3> <p>原始快照相对增量更新效率会高(可能造成更多的浮动垃圾)，因为不需要在重新标记阶段再次深度扫描被删除引用对象（黑色对象新插入白色对象或灰色对象的引用）而且G1 针对的是大内存的环境下，深度扫描会导致时间更久了，而CMS对增量引用的根对象会做深度扫描，G1因为很多对象都位于不同的region，CMS就一块老年代区域，重新深度扫描对象的话G1的代价会比CMS高，所以G1选择SATB不深度扫描对象，只是简单标记，等到下一轮GC再深度扫描。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/back/jvm/ClassLoader.html" class="prev">
        类加载
      </a></span> <span class="next"><a href="/back/jvm/jvm问题.html">
        jvm 知识点
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.eb78e4ff.js" defer></script><script src="/assets/js/2.062734e7.js" defer></script><script src="/assets/js/21.3b3ad479.js" defer></script>
  </body>
</html>
